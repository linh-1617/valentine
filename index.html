<!DOCTYPE html>
<html>
  <head>
    <title>Va len tin Bích Liên</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&display=swap');

      /* =========================================
         ĐIỀN ĐÚNG TÊN ẢNH CỦA BẠN VÀO ĐÂY
         ========================================= */
      :root {
        --img-url: url('z7426495048507_ddd8af995c6067cb5348b5b3cebc525d.jpg'); 
      }

      html, body {
        height: 100%;
        padding: 0;
        margin: 0;
        background: #000;
        overflow: hidden; 
        font-family: 'Arial', sans-serif;
        color: white;
      }

      /* =========================================
         PHẦN 1: GIAO DIỆN TRÒ CHƠI GHÉP HÌNH
         ========================================= */
      #puzzle-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        height: 100vh;
        width: 100%;
        position: absolute;
        z-index: 50;
        transition: opacity 1s ease;
        padding-top: 5vh;
        padding-bottom: 80px; 
        box-sizing: border-box;
        overflow-y: auto; 
      }

      #puzzle-container h2 {
        color: #ff3490;
        text-shadow: 0 0 15px #ff3490;
        margin-bottom: 5px;
        text-align: center;
        font-size: 26px;
      }

      .guide-text {
        font-size: 14px;
        color: #ccc;
        margin-bottom: 20px;
        text-align: center;
        padding: 0 10px;
      }

      #puzzle-board {
        width: 270px;
        height: 360px;
        display: grid;
        grid-template-columns: repeat(3, 90px);
        grid-template-rows: repeat(3, 120px);
        background: rgba(20, 20, 20, 0.8);
        border: 2px solid #ff3490;
        border-radius: 6px;
        box-shadow: 0 0 20px rgba(255, 52, 144, 0.6);
        margin-bottom: 20px;
        flex-shrink: 0;
      }

      .puzzle-slot {
        width: 90px;
        height: 120px;
        border: 1px dashed rgba(255, 52, 144, 0.4);
        box-sizing: border-box;
      }

      #pieces-pool {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 6px;
        width: 300px;
        min-height: 120px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        flex-shrink: 0;
      }

      .puzzle-piece {
        width: 90px;
        height: 120px;
        background-image: var(--img-url);
        background-size: 270px 360px;
        background-repeat: no-repeat;
        cursor: grab;
        border-radius: 2px;
        box-sizing: border-box;
        box-shadow: 0 0 5px rgba(0,0,0,0.5);
        touch-action: none; 
      }

      .puzzle-piece:active { cursor: grabbing; }

      .is-dragging {
        transform: scale(1.1);
        box-shadow: 0 10px 20px rgba(0,0,0,0.5), 0 0 10px #fff inset;
        border: 2px solid #fff;
        opacity: 0.9;
        z-index: 9999;
      }

      /* =========================================
         PHẦN 2: GẤU BÔNG PHÁC THẢO & TRÁI TIM
         ========================================= */
      #animation-container {
        display: none;
        width: 100%;
        height: 100%;
        position: absolute;
      }

      .title-container {
        position: absolute;
        top: 8%;
        width: 100%;
        text-align: center;
        z-index: 20;
      }
      .title-container h1 {
        color: #ff3490;
        font-size: 40px;
        margin: 0;
        text-shadow: 0 0 15px #ff3490, 0 0 25px #ff3490;
      }

      #biu-container {
        position: absolute;
        bottom: 5%;
        left: 5%;
        z-index: 15;
      }

      /* Đảm bảo SVG có thể thu phóng mượt mà */
      #biu-container svg {
        width: 100%;
        height: auto;
      }

      .sketch-shape {
        stroke: #fde0b2; 
        stroke-width: 3.5;
        fill: transparent;
        stroke-linecap: round;
        stroke-linejoin: round;
        stroke-dasharray: 1200;
        stroke-dashoffset: 1200;
      }
      .start-anim .sketch-shape { animation: draw-sketch 3.5s ease-in-out forwards, shape-fill-sketch 1s 3.5s forwards; }

      .sketch-limb {
        stroke: #fde0b2;
        stroke-width: 14;
        stroke-linecap: round;
        fill: transparent;
        stroke-dasharray: 600;
        stroke-dashoffset: 600;
      }
      .start-anim .sketch-limb { animation: draw-sketch 3.5s ease-in-out forwards; }

      .sketch-detail {
        stroke: #fde0b2;
        stroke-width: 2.5;
        fill: transparent;
        stroke-linecap: round;
        stroke-dasharray: 200;
        stroke-dashoffset: 200;
      }
      .start-anim .sketch-detail { animation: draw-sketch 2s ease-in-out 1.5s forwards; }

      .face-elements { opacity: 0; }
      .start-anim .face-elements { animation: fade-in 0.6s 3.7s forwards; }

      .biu-elements { opacity: 0; transform-origin: 275px 135px; }
      .start-anim .biu-elements { animation: pop-in 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) 4.2s forwards; }

      .biu-text { font-family: 'Dancing Script', cursive; font-size: 48px; fill: #ff8da1; }

      .box {
        width: 100%; height: 100%; position: absolute;
        top: 0; left: 0; z-index: 10; opacity: 0; 
      }
      .start-anim .box { animation: fade-in 2s linear 4.8s forwards; }

      canvas { position: absolute; width: 100%; height: 100%; }
      #pinkboard { animation: heartbeat 1.5s infinite 5s; }

      @keyframes draw-sketch { to { stroke-dashoffset: 0; } }
      @keyframes shape-fill-sketch { to { fill: rgba(253, 224, 178, 0.08); } } 
      @keyframes fade-in { to { opacity: 1; } }
      @keyframes pop-in {
        0% { opacity: 0; transform: scale(0.2) translate(-20px, 20px); }
        70% { opacity: 1; transform: scale(1.1) translate(0, 0); }
        100% { opacity: 1; transform: scale(1); }
      }
      @keyframes heartbeat {
        0% { transform: scale(1); }
        50% { transform: scale(1.1); }
        100% { transform: scale(1); }
      }

      /* =========================================
         TỐI ƯU HÓA HIỂN THỊ TRÊN ĐIỆN THOẠI (FIXED)
         ========================================= */
      @media (max-width: 600px) {
        .title-container {
          top: 8%; /* Đẩy tiêu đề lên một chút */
        }
        .title-container h1 {
          font-size: 24px; /* Tiêu đề nhỏ gọn tinh tế hơn */
          padding: 0 10px;
        }
        #biu-container {
          bottom: 2%; /* Nằm sát đáy hơn */
          left: 2%; /* Ôm lề trái */
          width: 45vw; /* Thu nhỏ gấu lại chỉ còn 45% màn hình */
          max-width: 160px; /* Khóa kích thước để gấu luôn nhỏ nhắn dễ thương */
        }
        /* Đã xóa thuộc tính .biu-text ở đây để nó tự động nhỏ lại theo đúng tỷ lệ của gấu */
      }
    </style>
  </head>
  <body>

    <div id="puzzle-container">
      <h2>Hỏng có chơi ăn gian nhó</h2>
      <p class="guide-text">Dùng ngón tay kéo thả mảnh ghép vào đúng ô trống trên khung</p>
      
      <div id="puzzle-board"></div>
      <div id="pieces-pool"></div>
    </div>

    <div id="animation-container">
      <div class="title-container">
        <h1>Bích Liên Valentine dui dẻee</h1>
      </div>

      <div id="biu-container">
        <svg viewBox="0 0 350 320">
          <defs>
            <filter id="pencil-sketch" x="-20%" y="-20%" width="140%" height="140%">
              <feTurbulence type="fractalNoise" baseFrequency="0.04" numOctaves="2" result="noise" />
              <feDisplacementMap in="SourceGraphic" in2="noise" scale="3" xChannelSelector="R" yChannelSelector="G" />
            </filter>
          </defs>

          <g filter="url(#pencil-sketch)">
            <circle cx="100" cy="90" r="22" class="sketch-shape" />
            <circle cx="100" cy="90" r="10" class="sketch-shape" />
            <circle cx="200" cy="90" r="22" class="sketch-shape" />
            <circle cx="200" cy="90" r="10" class="sketch-shape" />

            <ellipse cx="115" cy="285" rx="22" ry="25" class="sketch-shape" />
            <ellipse cx="185" cy="285" rx="22" ry="25" class="sketch-shape" />

            <ellipse cx="150" cy="220" rx="60" ry="70" class="sketch-shape" />

            <path d="M 100 190 Q 70 230 90 260" class="sketch-limb" />
            
            <path d="M 200 190 Q 230 180 260 160" class="sketch-limb" />

            <ellipse cx="150" cy="130" rx="70" ry="60" class="sketch-shape" />

            <ellipse cx="150" cy="150" rx="25" ry="18" class="sketch-shape" />

            <path d="M 120 230 L 140 220 L 150 240 L 130 250 Z" class="sketch-detail" />
            <line x1="125" y1="235" x2="145" y2="235" class="sketch-detail" />
            <line x1="135" y1="225" x2="135" y2="245" class="sketch-detail" />
            
            <line x1="120" y1="85" x2="140" y2="105" class="sketch-detail" />
            <line x1="130" y1="85" x2="120" y2="95" class="sketch-detail" />
            <line x1="140" y1="95" x2="130" y2="105" class="sketch-detail" />

            <g class="face-elements">
              <circle cx="125" cy="125" r="5" fill="#fde0b2" />
              <circle cx="175" cy="125" r="5" fill="#fde0b2" />
              
              <ellipse cx="150" cy="143" rx="8" ry="5" fill="#fde0b2" />
              
              <path d="M 150 148 L 150 155 M 140 160 Q 150 163 150 155 M 160 160 Q 150 163 150 155" stroke="#fde0b2" stroke-width="3" fill="none" stroke-linecap="round" />
              
              <ellipse cx="105" cy="140" rx="10" ry="6" fill="#ff8da1" opacity="0.6" />
              <ellipse cx="195" cy="140" rx="10" ry="6" fill="#ff8da1" opacity="0.6" />
            </g>

            <g class="biu-elements">
              <path d="M 275 120 C 270 110, 260 115, 260 125 C 260 135, 275 150, 275 150 C 275 150, 290 135, 290 125 C 290 115, 280 110, 275 120 Z" fill="#ff8da1" stroke="#ff8da1" stroke-width="2" />
              <text x="265" y="175" class="biu-text" transform="rotate(-15 270 170)">biu</text>
            </g>
          </g>
        </svg>
      </div>

      <div class="box">
        <canvas id="pinkboard"></canvas>
      </div>
    </div>

    <script>
      /* =========================================
         LOGIC GAME KÉO THẢ TƯƠNG THÍCH MỌI THIẾT BỊ
         ========================================= */
      const board = document.getElementById('puzzle-board');
      const pool = document.getElementById('pieces-pool');

      for(let i = 0; i < 9; i++) {
        let slot = document.createElement('div');
        slot.className = 'puzzle-slot';
        slot.dataset.index = i;
        board.appendChild(slot);
      }

      let indices = [0, 1, 2, 3, 4, 5, 6, 7, 8];
      indices.sort(() => Math.random() - 0.5); 

      let activePiece = null;
      let startX = 0, startY = 0;
      let initialLeft = 0, initialTop = 0;

      indices.forEach(i => {
        let piece = document.createElement('div');
        piece.className = 'puzzle-piece';
        piece.dataset.index = i; 

        let row = Math.floor(i / 3);
        let col = i % 3;
        piece.style.backgroundPosition = `-${col * 90}px -${row * 120}px`;

        piece.addEventListener('touchstart', function(e) {
          activePiece = this;
          let touch = e.touches[0];
          let rect = this.getBoundingClientRect();
          
          startX = touch.clientX;
          startY = touch.clientY;
          initialLeft = rect.left;
          initialTop = rect.top;

          this.style.position = 'fixed';
          this.style.left = initialLeft + 'px';
          this.style.top = initialTop + 'px';
          this.classList.add('is-dragging');
        }, {passive: false});

        piece.addEventListener('touchmove', function(e) {
          if (!activePiece) return;
          e.preventDefault(); 
          let touch = e.touches[0];
          let dx = touch.clientX - startX;
          let dy = touch.clientY - startY;
          this.style.left = (initialLeft + dx) + 'px';
          this.style.top = (initialTop + dy) + 'px';
        }, {passive: false});

        piece.addEventListener('touchend', function(e) {
          if (!activePiece) return;
          this.classList.remove('is-dragging');
          
          this.style.display = 'none';
          let touch = e.changedTouches[0];
          let target = document.elementFromPoint(touch.clientX, touch.clientY);
          this.style.display = 'block';

          this.style.position = 'static';
          this.style.left = '';
          this.style.top = '';

          if (target && target.classList.contains('puzzle-slot') && target.children.length === 0) {
            target.appendChild(this);
            checkWin();
          } 
          else if (target && target.closest('#pieces-pool')) {
            pool.appendChild(this);
          }
          activePiece = null;
        });

        piece.draggable = true;
        piece.addEventListener('dragstart', function(e) {
          activePiece = this;
          setTimeout(() => this.classList.add('is-dragging'), 0);
        });
        piece.addEventListener('dragend', function() {
          this.classList.remove('is-dragging');
          activePiece = null;
        });

        pool.appendChild(piece);
      });

      document.querySelectorAll('.puzzle-slot').forEach(slot => {
        slot.addEventListener('dragover', e => e.preventDefault());
        slot.addEventListener('drop', function(e) {
          e.preventDefault();
          if (activePiece && this.children.length === 0) {
            this.appendChild(activePiece);
            checkWin();
          }
        });
      });
      pool.addEventListener('dragover', e => e.preventDefault());
      pool.addEventListener('drop', function(e) {
        e.preventDefault();
        if (activePiece) this.appendChild(activePiece);
      });

      function checkWin() {
        let slots = document.querySelectorAll('.puzzle-slot');
        let isWin = true;
        slots.forEach(slot => {
          let piece = slot.firstElementChild;
          if (!piece || piece.dataset.index !== slot.dataset.index) {
            isWin = false;
          }
        });

        if (isWin) {
          setTimeout(triggerSuccess, 500); 
        }
      }

      function triggerSuccess() {
        const puzzleContainer = document.getElementById('puzzle-container');
        puzzleContainer.style.opacity = '0';
        
        setTimeout(() => {
          puzzleContainer.style.display = 'none';
          document.getElementById('animation-container').style.display = 'block';
          document.body.classList.add('start-anim');
          setTimeout(startHeartAnimation, 4500); 
        }, 1000); 
      }

      var settings = { particles: { length: 5000, duration: 2.5, velocity: 200, effect: -0.6, size: 13 } };
      var Point = (function () {
        function Point(x, y) { this.x = x || 0; this.y = y || 0; }
        Point.prototype.clone = function () { return new Point(this.x, this.y); };
        Point.prototype.length = function (length) {
          if (typeof length == "undefined") return Math.sqrt(this.x * this.x + this.y * this.y);
          this.normalize(); this.x *= length; this.y *= length; return this;
        };
        Point.prototype.normalize = function () {
          var length = this.length(); this.x /= length; this.y /= length; return this;
        };
        return Point;
      })();
      var Particle = (function () {
        function Particle() {
          this.position = new Point(); this.velocity = new Point();
          this.acceleration = new Point(); this.age = 0;
        }
        Particle.prototype.initialize = function (x, y, dx, dy) {
          this.position.x = x; this.position.y = y;
          this.velocity.x = dx; this.velocity.y = dy;
          this.acceleration.x = dx * settings.particles.effect;
          this.acceleration.y = dy * settings.particles.effect;
          this.age = 0;
        };
        Particle.prototype.update = function (deltaTime) {
          this.position.x += this.velocity.x * deltaTime;
          this.position.y += this.velocity.y * deltaTime;
          this.velocity.x += this.acceleration.x * deltaTime;
          this.velocity.y += this.acceleration.y * deltaTime;
          this.age += deltaTime;
        };
        Particle.prototype.draw = function (context, image) {
          function ease(t) { return --t * t * t + 1; }
          var size = image.width * ease(this.age / settings.particles.duration);
          context.globalAlpha = 1 - this.age / settings.particles.duration;
          context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);
        };
        return Particle;
      })();
      var ParticlePool = (function () {
        var particles, firstActive = 0, firstFree = 0, duration = settings.particles.duration;
        function ParticlePool(length) {
          particles = new Array(length);
          for (var i = 0; i < particles.length; i++) particles[i] = new Particle();
        }
        ParticlePool.prototype.add = function (x, y, dx, dy) {
          particles[firstFree].initialize(x, y, dx, dy);
          firstFree++; if (firstFree == particles.length) firstFree = 0;
          if (firstActive == firstFree) firstActive++; if (firstActive == particles.length) firstActive = 0;
        };
        ParticlePool.prototype.update = function (deltaTime) {
          var i;
          if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].update(deltaTime); }
          if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].update(deltaTime); for (i = 0; i < firstFree; i++) particles[i].update(deltaTime); }
          while (particles[firstActive].age >= duration && firstActive != firstFree) {
            firstActive++; if (firstActive == particles.length) firstActive = 0;
          }
        };
        ParticlePool.prototype.draw = function (context, image) {
          if (firstActive < firstFree) { for (i = firstActive; i < firstFree; i++) particles[i].draw(context, image); }
          if (firstFree < firstActive) { for (i = firstActive; i < particles.length; i++) particles[i].draw(context, image); for (i = 0; i < firstFree; i++) particles[i].draw(context, image); }
        };
        return ParticlePool;
      })();

      function startHeartAnimation() {
        var canvas = document.getElementById("pinkboard");
        var context = canvas.getContext("2d"),
          particles = new ParticlePool(settings.particles.length),
          particleRate = settings.particles.length / settings.particles.duration,
          time;

        function pointOnHeart(t) {
          return new Point(
            160 * Math.pow(Math.sin(t), 3),
            130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
          );
        }
        var image = (function () {
          var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
          canvas.width = settings.particles.size; canvas.height = settings.particles.size;
          function to(t) {
            var point = pointOnHeart(t);
            point.x = settings.particles.size / 2 + (point.x * settings.particles.size) / 350;
            point.y = settings.particles.size / 2 - (point.y * settings.particles.size) / 350;
            return point;
          }
          context.beginPath(); var t = -Math.PI; var point = to(t);
          context.moveTo(point.x, point.y);
          while (t < Math.PI) { t += 0.01; point = to(t); context.lineTo(point.x, point.y); }
          context.closePath(); context.fillStyle = "#ff3490"; context.fill();
          var image = new Image(); image.src = canvas.toDataURL(); return image;
        })();

        function render() {
          requestAnimationFrame(render);
          var newTime = new Date().getTime() / 1000, deltaTime = newTime - (time || newTime);
          time = newTime;
          context.clearRect(0, 0, canvas.width, canvas.height);
          var amount = particleRate * deltaTime;
          for (var i = 0; i < amount; i++) {
            var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
            var dir = pos.clone().length(settings.particles.velocity);
            particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
          }
          particles.update(deltaTime);
          particles.draw(context, image);
        }
        function onResize() {
          var heightRatio = 1.5;
          canvas.width = canvas.clientWidth * heightRatio;
          canvas.height = canvas.clientHeight * heightRatio;
        }
        window.onresize = onResize;
        onResize();
        render();
      }
    </script>
  </body>
</html>
